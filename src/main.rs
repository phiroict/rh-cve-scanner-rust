mod afflicted_struct;
mod constants;
mod cve_struct;
mod logging;
mod pods_struct;
use log::{debug, error, info, trace, warn};

use crate::afflicted_struct::Afflicted;
use crate::cve_struct::{CVE, CVES};
use crate::pods_struct::{Container, Item, Pods};
use std::collections::HashMap;
use std::error::Error;
use std::process::Command;
use std::str;
use tokio;

async fn get_cves_from_redhat() -> Result<CVES, Box<dyn Error>> {
    let url = constants::CVE_URL;
    let result = reqwest::get(url).await?.text().await?;
    let cve_collection: CVES = serde_json::from_str(&result)?;

    Ok(cve_collection)
}

async fn _get_images_from_pods(pods: Pods) {
    info!("Found {} pods", pods.items.len())
}

async fn get_images_from_cluster(
    cves: CVES,
    mut cluster_images: HashMap<String, Item>,
) -> (HashMap<String, Item>, CVES) {
    // println!("Result object: {:?}", cves);
    let namespaces = get_namespaces();
    for namespace in namespaces.split("\n") {
        if namespace.is_empty() {
            continue;
        };
        let normalized_namespace = namespace.replace("namespace/", "");
        info!("Processing namespace {}", &normalized_namespace);
        let pods_result = get_pods_json(&normalized_namespace);
        let pods = match pods_result {
            Ok(p) => p,
            Err(e) => {
                error!(
                    "Could not process this namespace: {} - error: {:?}",
                    normalized_namespace, e
                );
                Pods {
                    api_version: "0".to_string(),
                    items: vec![],
                    kind: "Error".to_string(),
                    metadata: Default::default(),
                }
            }
        };
        info!("--> Number of pods found: {}", pods.items.len());
        for pod in pods.items {
            let podname = pod.metadata.name.clone();
            cluster_images.insert(podname, pod);
        }
    }
    (cluster_images, cves)
}

fn get_pods_json(namespace: &str) -> Result<Pods, Box<dyn Error>> {
    let pods_parser_command = constants::OC_GET_PODS.replace("*ns*", namespace);
    info!(
        "--> parsing pods with the command '{}'",
        &pods_parser_command
    );
    let result = call_oc_commandline(&pods_parser_command);
    let pods_json = match result {
        Ok(s) => s.to_string(),
        Err(_) => "{}".to_string(),
    };
    let pods_object: Pods = serde_json::from_str(&pods_json)?;
    Ok(pods_object)
}

fn get_namespaces() -> String {
    let r = call_oc_commandline(constants::OC_GET_NAMESPACES);
    let result = match r {
        Ok(r) => r.to_string(),
        Err(_) => "".to_string(),
    };
    result
}

fn call_oc_commandline(command: &str) -> Result<String, String> {
    trace!("Starting to parse the command to call: {}", command);
    let output = Command::new("sh")
        .arg("-c")
        .arg(command)
        .output()
        .expect("Could not call this command");
    trace!(
        "Value of stdout is {}",
        str::from_utf8(&output.stdout).unwrap_or("none")
    );
    trace!(
        "Value of stderr is {}",
        str::from_utf8(&output.stderr).unwrap_or("none")
    );
    if output.stdout.is_empty() {
        error!(
            "Could not read output for the command: {:?} returning an empty response",
            str::from_utf8(&output.stderr).unwrap_or("")
        )
    }
    let result = match str::from_utf8(&output.stdout) {
        Ok(r) => r.to_string(),
        Err(e) => {
            error!("Could not create utf8 from array {:?}", e);
            return Err(String::from(
                "Failed to convert result to utf8 string, this may be binary?",
            ));
        }
    };
    Ok(result)
}

fn process_cluster_images(pods: HashMap<String, Item>, cves: Vec<CVE>) -> Vec<Afflicted> {
    let mut afflicted_pods: Vec<Afflicted> = Vec::new();
    for pod in pods.keys() {
        let p = match pods.get(pod) {
            None => {
                panic!("Could not resolve this item");
            }
            Some(p) => p,
        };
        let containers = &p.spec.containers;
        for container in containers {
            let image = &container.image;
            info!(
                "----> Images found for {} image {}",
                &p.metadata.name, image
            );
            let afflicted = match_cve_to_cluster_image(&cves, p);
            match afflicted {
                None => {
                    println!("----> No CVEs for this pod, skipping")
                }
                Some(a) => {
                    afflicted_pods.insert(0, a);
                }
            }
        }
    }
    afflicted_pods
}

fn match_cve_to_cluster_image(_cves: &CVES, item: &Item) -> Option<Afflicted> {
    let images: Vec<String> = Vec::new();
    let _images_to_match = convert_hash_to_version(item, images);
    None
}

fn convert_hash_to_version(item: &Item, mut images: Vec<String>) {
    let containers = &item.spec.containers;
    trace!(
        "Found {} containers in pod {}",
        containers.len(),
        item.metadata.name
    );
    for container in containers {
        let image = &container.image;
        trace!("Starting to process container: {}", image);
        if image.contains("@") {
            extract_version_from_amp(&item, &mut images, container);
        } else {
            images.insert(0, image.clone());
        }
    }
}

/// Get the version by getting a description
/// It scans if a container image name has a '@' and then searches the version number from the pod description
fn extract_version_from_amp(item: &&Item, images: &mut Vec<String>, container: &Container) {
    let pod_describe_command = constants::OC_DESCRIBE_POD
        .replace("*ns*", &item.metadata.namespace)
        .replace("*pod*", &item.metadata.name);
    trace!(
        "pod describe command '{}' rewritten as '{}'",
        constants::OC_DESCRIBE_POD,
        &pod_describe_command
    );
    let description = call_oc_commandline(&pod_describe_command);
    match description {
        Ok(desc) => {
            let find_string = "Image:";

            let index = desc.find(find_string);
            let length_search_string = find_string.len();
            let ix_image = match index {
                None => 0,
                Some(ix) => ix,
            };
            trace!(
                "First match with '{}' is at index: {}",
                find_string,
                ix_image
            );
            if ix_image > 0 {
                let index_next_return = desc[ix_image..].find("\n");
                match index_next_return {
                    None => {
                        warn!("Could not find the end of the line from this line");
                    }
                    Some(ix) => {
                        trace!(
                            "Found the end of the line after the search string at {}",
                            ix
                        );
                        let total_length = desc.len();
                        debug!(
                            "Check: ix:{0} < total_length: {1}?, ix:{0} < ix_image: {2}",
                            ix,
                            desc.len(),
                            ix_image
                        );
                        if ix <= total_length && ix < ix_image {
                            trace!("Match ok, continuing");
                            let image_version_string = &desc[(ix_image + length_search_string)
                                ..(ix + ix_image + length_search_string - 2)]
                                .trim();
                            trace!(
                                "Image cutout from description is' '{}'",
                                image_version_string
                            );
                            images.insert(0, image_version_string.to_string());
                        } else {
                            warn!("Match nok, check values of the previous debug line");
                        }
                    }
                }
            } else {
                warn!(
                    "Could not extract the version for this container: {}",
                    &container.name
                );
            }
        }
        Err(_) => {
            error!(
                "Could not fetch the version for this pod: {}",
                item.metadata.name
            )
        }
    }
}

async fn init_logging() {
    logging::initialize_logging();
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    //! Entry point process:
    //! - Initialize the logging framework
    //! - Read the CVEs from redhat
    //! - Read the containers from the cluster the `oc` executable is logged into
    //! - Matches the vulnerable instances and list it out.
    //! The process is asynchronous and is expected to run in seconds, this may be slower in cloud
    //! platforms as the communication may be slower, the system makes a lot of oc calls to get the
    //! information.
    init_logging().await;
    info!("At start application");
    let cves = get_cves_from_redhat().await;
    let cluster_images: HashMap<String, Item> = HashMap::new();
    match cves {
        Ok(cves) => {
            info!("Got cves ok");
            let (cluster_images, cves) = get_images_from_cluster(cves, cluster_images).await;
            let _images = process_cluster_images(cluster_images, cves);
        }
        Err(err) => {
            error!("Could not read the cves: {:?}", err);
        }
    }
    info!("At end application");
    Ok(())
}

// ----- TESTS -------------
#[cfg(test)]
mod tests {
    use crate::pods_struct::{Container, Item, Metadata, Spec};
    use crate::{
        call_oc_commandline, constants, convert_hash_to_version, get_namespaces, init_logging,
    };
    use log::info;
    use tokio::sync::OnceCell;

    use tokio::test;

    static LOG_INIT: OnceCell<String> = OnceCell::const_new();

    async fn initialize() -> &'static String {
        LOG_INIT
            .get_or_init(|| async {
                init_logging().await;
                "test".to_string()
            })
            .await
    }

    #[test]
    async fn call_external_command() {
        initialize().await;
        let r = call_oc_commandline("echo test");
        let result = match r {
            Ok(r) => r,
            Err(_) => "".to_string(),
        };
        assert_eq!(result, String::from("test\n"));
    }

    #[test]
    async fn call_external_get_namespaces() {
        initialize().await;
        let r = call_oc_commandline(constants::OC_GET_NAMESPACES);
        let result = match r {
            Ok(r) => r,
            Err(_) => "".to_string(),
        };
        assert!(result.len() > 10);
    }

    #[test]
    async fn iterate_over_namespaces() {
        initialize().await;
        let ns = get_namespaces();
        let parts = ns.split("\n");
        let mut count = 0;
        for part in parts {
            println!("ns found {}", part);
            count += 1;
        }
        assert!(count > 0);
    }

    #[test]
    async fn find_and_replace_hash() {
        initialize().await;
        let string_with_hash = "bla/image.cname@sha256blablabla";
        let string_wo_hash = "bla/image.cname:1.2.3";
        let ix_hash = string_with_hash.find("@");
        let ix = match ix_hash {
            None => 0,
            Some(ix) => ix,
        };
        assert_eq!(ix, 15);
        let ix_hash = string_wo_hash.find("@");
        let ix = match ix_hash {
            None => 0,
            Some(ix) => ix,
        };
        assert_eq!(ix, 0);
    }

    #[test]
    async fn substring_finding() {
        initialize().await;
        let string_image = "Bla: fla\nImage: image.cname:1.2.3\nRest of the file \n";
        let ix_image = string_image.find("Image:");
        let ix = match ix_image {
            None => 0,
            Some(ix) => ix,
        };
        let part_string = &string_image[ix..];
        assert_eq!(part_string, "Image: image.cname:1.2.3\nRest of the file \n");
        let size_image_string = "Image:".len();
        assert_eq!(
            &string_image[ix + size_image_string..],
            " image.cname:1.2.3\nRest of the file \n"
        );

        let ix_next_return = string_image[ix + size_image_string..].find("\n");

        let ix_end = match ix_next_return {
            None => 0,
            Some(ux) => ux,
        };
        info!("Ix_end is {}", ix_end);

        let checkstring =
            string_image[(ix + size_image_string)..(ix_end + ix + size_image_string)].trim();
        info!(
            "Cut string is '{}', from {} to {} length of the image part is {}",
            checkstring,
            (ix),
            ix_end,
            size_image_string
        );
        assert_eq!("image.cname:1.2.3", checkstring);
    }

    #[test]
    async fn get_namespaces_list() {
        initialize().await;
        let namespaces_result = call_oc_commandline(constants::OC_GET_NAMESPACES);
        let namespaces = match namespaces_result {
            Ok(r) => r,
            Err(_) => "none".to_string(),
        };
        info!("Namespace list extracted is {}", namespaces);
        let expected_value = "namespace/default\nnamespace/hostpath-provisioner\nnamespace/kube-node-lease\nnamespace/kube-public\nnamespace/kube-system\nnamespace/openshift\nnamespace/openshift-apiserver\nnamespace/openshift-apiserver-operator\nnamespace/openshift-authentication\nnamespace/openshift-authentication-operator\nnamespace/openshift-cloud-controller-manager\nnamespace/openshift-cloud-controller-manager-operator\nnamespace/openshift-cloud-credential-operator\nnamespace/openshift-cloud-network-config-controller\nnamespace/openshift-cluster-machine-approver\nnamespace/openshift-cluster-node-tuning-operator\nnamespace/openshift-cluster-samples-operator\nnamespace/openshift-cluster-storage-operator\nnamespace/openshift-cluster-version\nnamespace/openshift-config\nnamespace/openshift-config-managed\nnamespace/openshift-config-operator\nnamespace/openshift-console\nnamespace/openshift-console-operator\nnamespace/openshift-console-user-settings\nnamespace/openshift-controller-manager\nnamespace/openshift-controller-manager-operator\nnamespace/openshift-dns\nnamespace/openshift-dns-operator\nnamespace/openshift-etcd\nnamespace/openshift-etcd-operator\nnamespace/openshift-host-network\nnamespace/openshift-image-registry\nnamespace/openshift-infra\nnamespace/openshift-ingress\nnamespace/openshift-ingress-canary\nnamespace/openshift-ingress-operator\nnamespace/openshift-kni-infra\nnamespace/openshift-kube-apiserver\nnamespace/openshift-kube-apiserver-operator\nnamespace/openshift-kube-controller-manager\nnamespace/openshift-kube-controller-manager-operator\nnamespace/openshift-kube-scheduler\nnamespace/openshift-kube-scheduler-operator\nnamespace/openshift-kube-storage-version-migrator\nnamespace/openshift-kube-storage-version-migrator-operator\nnamespace/openshift-machine-api\nnamespace/openshift-machine-config-operator\nnamespace/openshift-marketplace\nnamespace/openshift-monitoring\nnamespace/openshift-multus\nnamespace/openshift-network-diagnostics\nnamespace/openshift-network-operator\nnamespace/openshift-node\nnamespace/openshift-nutanix-infra\nnamespace/openshift-oauth-apiserver\nnamespace/openshift-openstack-infra\nnamespace/openshift-operator-lifecycle-manager\nnamespace/openshift-operators\nnamespace/openshift-ovirt-infra\nnamespace/openshift-route-controller-manager\nnamespace/openshift-sdn\nnamespace/openshift-service-ca\nnamespace/openshift-service-ca-operator\nnamespace/openshift-user-workload-monitoring\nnamespace/openshift-vsphere-infra\n";
        assert_eq!(expected_value, namespaces);
    }

    #[test]
    async fn test_image_extractor() {
        initialize().await;
        let item = Item {
            api_version: "1".to_string(),
            kind: "Pod".to_string(),
            metadata: Metadata {
                annotations: None,
                creation_timestamp: "".to_string(),
                generate_name: None,
                labels: Default::default(),
                name: "alertmanager-main-0".to_string(),
                namespace: "openshift-monitoring".to_string(),
                owner_references: vec![],
                resource_version: "".to_string(),
                uid: "12".to_string(),
            },
            spec: Spec {
                containers: vec![Container {
                    env: vec![],
                    image: "quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:d19ca34862ba086f5e91db7c3f57fbc29c4b2184db5a943ad4a1c87e7729f7a7".to_string(),
                    image_pull_policy: "".to_string(),
                    name: "testcontainer".to_string(),
                    resources: Default::default(),
                    security_context: None,
                    termination_message_path: "".to_string(),
                    termination_message_policy: "".to_string(),
                    volume_mounts: vec![],
                    args: vec![],
                    liveness_probe: None,
                    ports: vec![],
                    command: vec![],
                    readiness_probe: None,
                    startup_probe: None,
                    lifecycle: None,
                    working_dir: None,
                }],
                dns_policy: "".to_string(),
                enable_service_links: false,
                image_pull_secrets: vec![],
                node_name: None,
                preemption_policy: "".to_string(),
                priority: 0,
                restart_policy: "".to_string(),
                scheduler_name: "".to_string(),
                security_context: Default::default(),
                service_account: None,
                service_account_name: None,
                termination_grace_period_seconds: 0,
                tolerations: vec![],
                volumes: vec![],
                affinity: None,
                node_selector: None,
                priority_class_name: None,
                init_containers: vec![],
                host_network: None,
                host_ipc: None,
                host_pid: None,
                share_process_namespace: None,
                automount_service_account_token: None,
                topology_spread_constraints: vec![],
            },
            status: Default::default(),
        };
        let list = Vec::new();
        convert_hash_to_version(&item, list.clone());
        assert_eq!(0, list.len());
    }
}
