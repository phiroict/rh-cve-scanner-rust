mod constants;
mod cve_struct;
mod pods_struct;
mod afflicted_struct;

use std::collections::HashMap;
use crate::cve_struct::{CVE, CVES};
use std::error::Error;
use tokio;
use std::process::Command;
use std::str;
use std::str::Split;
use crate::afflicted_struct::Afflicted;
use crate::pods_struct::{Item, Pods};


async fn get_cves_from_redhat() -> Result<CVES, Box<dyn Error>> {
    let url = constants::CVE_URL;
    let result = reqwest::get(url).await?.text().await?;
    let cve_collection: CVES = serde_json::from_str(&result)?;

    Ok(cve_collection)
}

async fn get_images_from_pods(pods: Pods){
    println!("Found {} pods", pods.items.len())
}

async fn get_images_from_cluster(cves: CVES, mut cluster_images: HashMap<String, Item>) -> (HashMap<String, Item>, CVES) {
    println!("Result object: {:?}", cves);
    let namespaces = get_namespaces();
    for namespace in namespaces.split("\n"){
        let normalized_namespace = namespace.replace("namespace/","");
        println!("Processing namespace {}", &normalized_namespace);
        let pods_result = get_pods_json(&normalized_namespace);
        let pods = match pods_result {
            Ok(p) => {p}
            Err(e) => {
                println!("Could not process this namespace: {} - error: {:?}", normalized_namespace, e);
                Pods{
                    api_version: "0".to_string(),
                    items: vec![],
                    kind: "Error".to_string(),
                    metadata: Default::default(),
                }
            }
        };
        println!("--> Number of pods found: {}", pods.items.len());
        for pod in pods.items {
            let podname = pod.metadata.name.clone();
            cluster_images.insert(podname, pod);
        }
    }
    (cluster_images, cves)
}

fn get_pods_json(namespace: &str) -> Result<Pods, Box<dyn Error>>{
    let pods_parser_command = constants::OC_GET_PODS.replace("*ns*", namespace);
    println!("--> parsing pods with the command '{}'", &pods_parser_command);
    let result = call_oc_commandline(&pods_parser_command);
    let pods_json = match result {
        Ok(s) => {s.to_string()}
        Err(_) => {"{}".to_string()}
    };
    let pods_object:Pods = serde_json::from_str(&pods_json)?;
    Ok(pods_object)

}

fn  get_namespaces() -> String {
    let r = call_oc_commandline(constants::OC_GET_NAMESPACES);
    let result = match r {
        Ok(r) => { r.to_string() }
        Err(_) => {"".to_string()}
    };
    result
}

fn call_oc_commandline(command: &str) -> Result<String, String> {
    let output = Command::new("sh")
        .arg("-c")
        .arg(command)
        .output()
        .expect("Could not call this command");
    let result = match str::from_utf8(&output.stdout) {
        Ok(r) => r.to_string(),
        Err(_) => return Err(String::from("Failed to convert result to utf8 string, this may be binary?")),
    };
    Ok(result)
}

fn process_cluster_images(pods: HashMap<String, Item>, cves: Vec<CVE>) -> Vec<Afflicted>{
    let mut afflicted_pods:Vec<Afflicted> = Vec::new();
    for pod in pods.keys() {
        let p = match pods.get(pod){
            None => {
                panic!("Could not resolve this item");
            }
            Some(p) => {p}
        };
        let containers = &p.spec.containers;
        for container in containers {
            let image = &container.image;
            println!("----> Images found for {} image {}", &p.metadata.name, image);
            let afflicted = match_cve_to_cluster_image(&cves, p);
            match afflicted {
                None => {println!("----> No CVEs for this pod, skipping")}
                Some(a) => {afflicted_pods.insert(0,a);}
            }
        }


    }
    afflicted_pods
}

fn match_cve_to_cluster_image(cves: &CVES, item:&Item) -> Option<Afflicted>{
    let mut images:Vec<&String> = Vec::new();
    let images_to_match = convert_hash_to_version(item, images);
    None
}

fn convert_hash_to_version(item: &Item, mut images: Vec<&String>)  {
    /* HIER GEBLEVEN */
    let containers = &item.spec.containers;
    for container in containers {
        let image = &container.image;
        if image.contains("@") {
            // Get the version by getting a description
            let pod_describe_command = constants::OC_DESCRIBE_POD.replace("*ns*", &item.metadata.namespace).replace("*pod*", &item.metadata.name);
            let description = call_oc_commandline(&pod_describe_command);
            match description {
                Ok(desc) => {
                    let index = desc.find("Image:");
                    let ix_image = match index {
                        None => {0}
                        Some(ix) => {ix}
                    };
                    if ix_image > 0 {
                        let index = desc[ix_image..].find("\n");
                        match index {
                            None => {/* Do nothing */}
                            Some(ix) => {
                                let image_version_string = &desc[ix_image+10..ix].trim();
                                images.insert(0, &image_version_string.to_string());

                            }
                        }
                    }
                }
                Err(_) => {
                    println!("Could not fetch the version for this pod: {}", item.metadata.name)
                }
            }
        } else {
            images.insert(0, image);
        }
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let cves = get_cves_from_redhat().await;
    let mut cluster_images: HashMap<String, Item> = HashMap::new();
    match cves {
        Ok(mut cves) => {
            let  (mut cluster_images, cves) = get_images_from_cluster(cves, cluster_images).await;
            let images = process_cluster_images(cluster_images, cves);
        }
        Err(err) => {
            println!("Could not read the cves: {:?}", err);
        }
    }

    Ok(())
}


#[cfg(test)]
mod tests {
    use crate::{call_oc_commandline, constants, get_namespaces};

    #[test]
    fn call_external_command(){
        let r = call_oc_commandline("echo test");
        let result = match r {
            Ok(r) => { r }
            Err(_) => {"".to_string()}
        };
        assert_eq!(result, String::from("test\n"));
    }

    #[test]
    fn call_external_get_namespaces(){
        let r = call_oc_commandline(constants::OC_GET_NAMESPACES);
        let result = match r {
            Ok(r) => { r }
            Err(_) => {"".to_string()}
        };
        assert!(result.len()>10);
    }

    #[test]
    fn iterate_over_namespaces() {

        let ns = get_namespaces();
        let parts = ns.split("\n");
        let mut count = 0;
        for part in parts {
            println!("ns found {}", part);
            count += 1;
        }
        assert!(count > 0);

    }
}