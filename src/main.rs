mod constants;
mod cve_struct;
mod pods_struct;

use crate::cve_struct::CVES;
use std::error::Error;
use tokio;
use std::process::Command;
use std::str;
use std::str::Utf8Error;

async fn get_cves_from_redhat() -> Result<CVES, Box<dyn Error>> {
    let url = constants::cve_url;
    let result = reqwest::get(url).await?.text().await?;
    let cve_collection: CVES = serde_json::from_str(&result)?;

    Ok(cve_collection)
}

async fn get_images_from_cluster(cves: CVES) {
    println!("Result object: {:?}", cves);
}

fn call_oc_commandline(command: &str) -> Result<String, String> {
    let output = Command::new("sh").arg("-c").arg(command).output().expect("Could not call this command");
    let result = match str::from_utf8(&output.stdout) {
        Ok(r) => r.to_string(),
        Err(_) => return Err(String::from("Failed to convert result to utf8 string, this may be binary?")),
    };
    Ok(result)
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let cves = get_cves_from_redhat().await;
    match cves {
        Ok(cves) => {
            get_images_from_cluster(cves).await;
        }
        Err(err) => {
            println!("Could not read the cves: {:?}", err);
        }
    }

    Ok(())
}


#[cfg(test)]
mod tests {
    use crate::call_oc_commandline;

    #[test]
    fn call_external_command(){
        let r = call_oc_commandline("echo test");
        let result = match r {
            Ok(r) => { r }
            Err(_) => {"".to_string()}
        };
        assert_eq!(result, String::from("test\n"));
    }
}